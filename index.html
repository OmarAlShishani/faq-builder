<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FAQ Batch Processor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #0f978e;
            --primary-hover: #4f46e5;
            --primary-light: #eef2ff;
            --success: #10b981;
            --success-light: #d1fae5;
            --error: #ef4444;
            --error-light: #fee2e2;
            --warning: #f59e0b;
            --warning-light: #fef3c7;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--primary);
            min-height: 100vh;
            padding: 24px;
            color: var(--gray-800);
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
            color: white;
        }

        .header h1 {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header p {
            font-size: 16px;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .card-header {
            padding: 16px 24px;
            background: var(--gray-50);
            border-bottom: 1px solid var(--gray-200);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s;
        }

        .card-header:hover {
            background: var(--gray-100);
        }

        .card-header h2 {
            font-size: 16px;
            font-weight: 600;
            color: var(--gray-700);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-header h2::before {
            content: '';
            width: 4px;
            height: 20px;
            background: var(--primary);
            border-radius: 2px;
        }

        .toggle-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--gray-400);
            transition: transform 0.3s;
        }

        .card-header.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .card-body {
            padding: 24px;
            transition: all 0.3s ease;
        }

        .card-body.collapsed {
            display: none;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 16px;
        }

        .form-row:last-child {
            margin-bottom: 0;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group.full {
            grid-column: 1 / -1;
        }

        label {
            font-size: 13px;
            font-weight: 500;
            color: var(--gray-600);
            margin-bottom: 6px;
        }

        label .required {
            color: var(--error);
        }

        input, select, textarea {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid var(--gray-300);
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            transition: all 0.2s;
            color: var(--gray-800);
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-light);
        }

        input::placeholder, textarea::placeholder {
            color: var(--gray-400);
        }

        textarea {
            min-height: 120px;
            resize: vertical;
            line-height: 1.5;
        }

        .hint {
            font-size: 12px;
            color: var(--gray-500);
            margin-top: 6px;
        }

        .hint a {
            color: var(--primary);
            text-decoration: none;
        }

        .hint a:hover {
            text-decoration: underline;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-primary:disabled {
            background: var(--gray-300);
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--gray-100);
            color: var(--gray-700);
        }

        .btn-secondary:hover {
            background: var(--gray-200);
        }

        .btn-group {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .btn-group .btn {
            flex: 1;
        }

        /* Progress Section */
        .progress-section {
            display: none;
        }

        .progress-section.active {
            display: block;
        }

        .progress-bar-container {
            background: var(--gray-200);
            border-radius: 8px;
            height: 8px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .progress-bar {
            height: 100%;
            /* background: linear-gradient(90deg, var(--primary), #a855f7); */
            border-radius: 8px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: var(--gray-600);
        }

        .progress-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .spinner-small {
            width: 16px;
            height: 16px;
            border: 2px solid var(--gray-200);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Results Section */
        .results-section {
            display: none;
        }

        .results-section.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: var(--gray-50);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--gray-800);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-card.success .stat-value { color: var(--success); }
        .stat-card.error .stat-value { color: var(--error); }
        .stat-card.primary .stat-value { color: var(--primary); }

        /* Question Results */
        .question-item {
            background: var(--gray-50);
            border-radius: 12px;
            margin-bottom: 12px;
            overflow: hidden;
            border: 1px solid var(--gray-200);
        }

        .question-header {
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s;
        }

        .question-header:hover {
            background: var(--gray-100);
        }

        .question-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--gray-700);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .question-number {
            background: var(--primary);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
        }

        .status-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-badge.success {
            background: var(--success-light);
            color: var(--success);
        }

        .status-badge.error {
            background: var(--error-light);
            color: var(--error);
        }

        .status-badge.partial {
            background: var(--warning-light);
            color: var(--warning);
        }

        .question-details {
            display: none;
            padding: 0 16px 16px;
            border-top: 1px solid var(--gray-200);
        }

        .question-details.open {
            display: block;
        }

        .lang-tabs {
            display: flex;
            gap: 8px;
            margin: 16px 0;
        }

        .lang-tab {
            padding: 8px 16px;
            border: none;
            background: var(--gray-200);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lang-tab.active {
            background: var(--primary);
            color: white;
        }

        .lang-content {
            display: none;
        }

        .lang-content.active {
            display: block;
        }

        .detail-section {
            margin-bottom: 16px;
        }

        .detail-section h4 {
            font-size: 12px;
            font-weight: 600;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .detail-content {
            background: white;
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            color: var(--gray-700);
            line-height: 1.6;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .tag {
            background: var(--primary-light);
            color: var(--primary);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .synonym-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .synonym-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .synonym-num {
            color: var(--gray-400);
            font-size: 11px;
            min-width: 20px;
        }

        /* API Status Grid */
        .api-status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 8px;
            margin-top: 12px;
        }

        .api-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 10px;
            background: white;
            border-radius: 6px;
            font-size: 11px;
        }

        .api-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .api-dot.success { background: var(--success); }
        .api-dot.error { background: var(--error); }
        .api-dot.pending { background: var(--gray-300); }

        .btn-retry-small {
            padding: 4px 8px;
            font-size: 10px;
            background: var(--warning);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: auto;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 24px;
            right: 24px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .toast {
            background: white;
            border-radius: 10px;
            padding: 14px 20px;
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 300px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.success { border-left: 4px solid var(--success); }
        .toast.error { border-left: 4px solid var(--error); }
        .toast.warning { border-left: 4px solid var(--warning); }
        .toast.info { border-left: 4px solid var(--primary); }

        .toast-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .toast.success .toast-icon { background: var(--success-light); color: var(--success); }
        .toast.error .toast-icon { background: var(--error-light); color: var(--error); }
        .toast.warning .toast-icon { background: var(--warning-light); color: var(--warning); }
        .toast.info .toast-icon { background: var(--primary-light); color: var(--primary); }

        .toast-message {
            font-size: 13px;
            color: var(--gray-700);
            flex: 1;
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--gray-400);
            cursor: pointer;
            padding: 4px;
        }

        /* Validation */
        .input-error {
            border-color: var(--error) !important;
        }

        .input-error:focus {
            box-shadow: 0 0 0 3px var(--error-light) !important;
        }

        .error-message {
            color: var(--error);
            font-size: 12px;
            margin-top: 4px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            body {
                padding: 16px;
            }

            .header h1 {
                font-size: 28px;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .btn-group {
                flex-direction: column;
            }

            .api-status-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 48px 24px;
            color: var(--gray-500);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div class="toast-container" id="toastContainer"></div>

    <div class="container">
        <div class="header">
            <h1>üöÄ FAQ Batch Processor</h1>
            <p>AI-powered FAQ content generation with automatic API submission</p>
        </div>

        <!-- API Configuration -->
        <div class="card">
            <div class="card-header" onclick="toggleCard(this)">
                <h2>API Configuration</h2>
                <span class="toggle-icon">‚ñº</span>
            </div>
            <div class="card-body">
                <div class="form-row">
                    <div class="form-group">
                        <label>Assistant Code</label>
                        <input type="text" id="assistantCode" value="li6monObUb" placeholder="Enter assistant code">
                    </div>
                    <div class="form-group">
                        <label>Version Code</label>
                        <input type="text" id="versionCode" value="li68VXoo7d" placeholder="Enter version code">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label>FAQ ID <span class="required">*</span></label>
                        <input type="text" id="faqId" placeholder="Enter FAQ ID">
                    </div>
                    <div class="form-group">
                        <label>JWT Token <span class="required">*</span></label>
                        <input type="password" id="jwt" placeholder="Enter JWT token">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group full">
                        <label>API Base URL</label>
                        <input type="text" id="baseURL" value="https://builder.datakite.app" placeholder="https://builder.datakite.app">
                        <p class="hint">Settings are automatically saved to your browser.</p>
                    </div>
                </div>
                </div>
            </div>

        <!-- AI Settings -->
        <div class="card">
            <div class="card-header" onclick="toggleCard(this)">
                <h2>AI Settings</h2>
                <span class="toggle-icon">‚ñº</span>
            </div>
            <div class="card-body">
                <div class="form-row">
                    <div class="form-group">
                        <label>AI Provider</label>
                        <select id="aiProvider" onchange="updateProviderSettings()">
                            <option value="gemini">Google Gemini (Recommended)</option>
                            <option value="openai">OpenAI</option>
                            <option value="openrouter">OpenRouter</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Model</label>
                        <select id="aiModel">
                            <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                        </select>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group full">
                        <label>API Key <span class="required">*</span></label>
                        <input type="password" id="apiKey" placeholder="Enter your AI API key">
                        <p class="hint" id="apiKeyHelp">Get your key from <a href="https://makersuite.google.com/app/apikey" target="_blank">Google AI Studio</a></p>
                        </div>
                    </div>
                </div>
            </div>

        <!-- Questions Input -->
        <div class="card">
            <div class="card-header">
                <h2>Questions Input</h2>
                <span class="toggle-icon" style="opacity: 0;">‚ñº</span>
            </div>
            <div class="card-body">
                <div class="form-group">
                    <label>Context / Instructions (Optional)</label>
                    <textarea id="aiInstructions" placeholder="Example: These FAQs are for an e-commerce platform selling electronics. Focus on product support, shipping, and returns.

ŸÖÿ´ÿßŸÑ: Ÿáÿ∞Ÿá ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑŸÖÿ™ÿ¨ÿ± ÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ŸÑÿ®Ÿäÿπ ÿßŸÑÿ£ÿ¨Ÿáÿ≤ÿ© ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸäÿ©. ÿ±ŸÉÿ≤ ÿπŸÑŸâ ÿØÿπŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™ ŸàÿßŸÑÿ¥ÿ≠ŸÜ ŸàÿßŸÑÿ•ÿ±ÿ¨ÿßÿπ." style="min-height: 80px;"></textarea>
                    <p class="hint">Provide context to help AI generate more accurate content.</p>
                    </div>
                <div class="form-group" style="margin-top: 16px;">
                    <label>FAQ Questions <span class="required">*</span> (one per line)</label>
                    <textarea id="questions" placeholder="How do I track my order?
ŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜŸä ÿ™ÿ™ÿ®ÿπ ÿ∑ŸÑÿ®Ÿäÿü
What is your return policy?
ŸÖÿß ŸáŸä ÿ≥Ÿäÿßÿ≥ÿ© ÿßŸÑÿ•ÿ±ÿ¨ÿßÿπÿü"></textarea>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" id="processBtn" onclick="processQuestions()">
                        <span>üöÄ</span> Process Questions
                    </button>
                    <button class="btn btn-secondary" onclick="clearAll()">
                        <span>üóëÔ∏è</span> Clear All
                    </button>
            </div>
                </div>
            </div>

        <!-- Progress Section -->
        <div class="card progress-section" id="progressSection">
            <div class="card-header">
                <h2>Processing Progress</h2>
                <span class="toggle-icon" style="opacity: 0;">‚ñº</span>
            </div>
            <div class="card-body">
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div class="progress-info">
                    <div class="progress-status">
                        <div class="spinner-small"></div>
                        <span id="progressText">Initializing...</span>
                    </div>
                    <span id="progressPercent">0%</span>
                </div>
            </div>
            </div>

            <!-- Results Section -->
        <div class="card results-section" id="resultsSection">
            <div class="card-header">
                <h2>Results</h2>
                <span class="toggle-icon" style="opacity: 0;">‚ñº</span>
                        </div>
            <div class="card-body">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalQuestions">0</div>
                        <div class="stat-label">Questions</div>
                        </div>
                    <div class="stat-card success">
                        <div class="stat-value" id="successCount">0</div>
                        <div class="stat-label">Successful</div>
                        </div>
                    <div class="stat-card error">
                        <div class="stat-value" id="errorCount">0</div>
                        <div class="stat-label">Failed</div>
                        </div>
                    <div class="stat-card primary">
                        <div class="stat-value" id="totalAPICalls">0</div>
                        <div class="stat-label">API Calls</div>
                    </div>
                </div>

                <div id="questionResults"></div>

                <div class="btn-group">
                    <button class="btn btn-primary" onclick="retryAllFailed()" id="retryBtn">
                        <span>üîÑ</span> Retry Failed
                    </button>
                    <button class="btn btn-secondary" onclick="exportResults()">
                        <span>üì•</span> Export Report
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let processedQuestions = [];
        let baseURL = 'https://builder.datakite.app';
        let isProcessing = false;

        // Model configurations
        const providerModels = {
            openai: [
                { value: 'gpt-4o-mini', label: 'GPT-4o Mini (Recommended)' },
                { value: 'gpt-4o', label: 'GPT-4o' },
                { value: 'gpt-4-turbo', label: 'GPT-4 Turbo' }
            ],
            gemini: [
                { value: 'gemini-2.0-flash', label: 'Gemini 2.0 Flash (Latest)' },
                { value: 'gemini-1.5-flash', label: 'Gemini 1.5 Flash' },
                { value: 'gemini-1.5-pro', label: 'Gemini 1.5 Pro' }
            ],
            openrouter: [
                { value: 'openai/gpt-4o-mini', label: 'OpenAI GPT-4o Mini' },
                { value: 'google/gemini-pro-1.5', label: 'Gemini Pro 1.5' },
                { value: 'anthropic/claude-3.5-sonnet', label: 'Claude 3.5 Sonnet' }
            ]
        };

        const providerInfo = {
            openai: { url: 'https://platform.openai.com/api-keys', text: 'OpenAI Platform' },
            gemini: { url: 'https://makersuite.google.com/app/apikey', text: 'Google AI Studio' },
            openrouter: { url: 'https://openrouter.ai/keys', text: 'OpenRouter' }
        };

        // Toast notifications
        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = { success: '‚úì', error: '‚úï', warning: '‚ö†', info: '‚Ñπ' };
            
            toast.innerHTML = `
                <div class="toast-icon">${icons[type]}</div>
                <div class="toast-message">${message}</div>
                <button class="toast-close" onclick="this.parentElement.remove()">‚úï</button>
            `;
            
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 5000);
        }

        // Card toggle
        function toggleCard(header) {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        }

        // Load settings
        window.addEventListener('DOMContentLoaded', () => {
            const fields = {
                'ai_provider': 'aiProvider',
                'ai_model': 'aiModel',
                'api_key': 'apiKey',
                'jwt_token': 'jwt',
                'assistant_code': 'assistantCode',
                'version_code': 'versionCode',
                'base_url': 'baseURL',
                'ai_instructions': 'aiInstructions',
                'faq_id': 'faqId'
            };

            const savedProvider = localStorage.getItem('ai_provider') || 'gemini';
            document.getElementById('aiProvider').value = savedProvider;
            updateProviderSettings();

            Object.entries(fields).forEach(([key, id]) => {
                if (key !== 'ai_provider') {
                    const saved = localStorage.getItem(key);
                    if (saved) document.getElementById(id).value = saved;
                }
            });
        });

        function updateProviderSettings() {
            const provider = document.getElementById('aiProvider').value;
            const modelSelect = document.getElementById('aiModel');
            const helpText = document.getElementById('apiKeyHelp');

            modelSelect.innerHTML = '';
            providerModels[provider].forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.label;
                modelSelect.appendChild(option);
            });

            const info = providerInfo[provider];
            helpText.innerHTML = `Get your key from <a href="${info.url}" target="_blank">${info.text}</a>`;
            localStorage.setItem('ai_provider', provider);
        }

        // Validation
        function validateForm() {
            const required = [
                { id: 'faqId', name: 'FAQ ID' },
                { id: 'jwt', name: 'JWT Token' },
                { id: 'apiKey', name: 'API Key' },
                { id: 'questions', name: 'Questions' }
            ];

            let isValid = true;
            document.querySelectorAll('.input-error').forEach(el => el.classList.remove('input-error'));

            for (const field of required) {
                const element = document.getElementById(field.id);
                if (!element.value.trim()) {
                    element.classList.add('input-error');
                    showToast(`${field.name} is required`, 'error');
                    isValid = false;
                }
            }

            return isValid;
        }

        // Save settings
        function saveSettings() {
            const fields = {
                'jwt_token': 'jwt',
                'assistant_code': 'assistantCode',
                'version_code': 'versionCode',
                'base_url': 'baseURL',
                'api_key': 'apiKey',
                'ai_provider': 'aiProvider',
                'ai_model': 'aiModel',
                'ai_instructions': 'aiInstructions',
                'faq_id': 'faqId'
            };

            Object.entries(fields).forEach(([key, id]) => {
                localStorage.setItem(key, document.getElementById(id).value);
            });
        }

        // Update progress
        function updateProgress(current, total, text) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progressBar').style.width = `${percent}%`;
            document.getElementById('progressPercent').textContent = `${percent}%`;
            document.getElementById('progressText').textContent = text;
        }

        async function processQuestions() {
            if (isProcessing) return;
            if (!validateForm()) return;

            saveSettings();
            
            const questionsText = document.getElementById('questions').value.trim();
            const questions = questionsText.split('\n').filter(q => q.trim() !== '');
            
            if (questions.length === 0) {
                showToast('Please enter at least one question', 'warning');
                return;
            }

            isProcessing = true;
            document.getElementById('processBtn').disabled = true;
            document.getElementById('progressSection').classList.add('active');
            document.getElementById('resultsSection').classList.remove('active');
            
            baseURL = document.getElementById('baseURL').value.trim();
            const aiInstructions = document.getElementById('aiInstructions').value.trim();

            processedQuestions = [];
            const totalSteps = questions.length * 2; // AI + API for each
            let currentStep = 0;

            try {
                for (let i = 0; i < questions.length; i++) {
                    const question = questions[i].trim();
                    
                    updateProgress(currentStep, totalSteps, `Generating AI content for Q${i + 1}...`);
                    
                    try {
                    const questionData = await processQuestion(question, i + 1, aiInstructions);
                    processedQuestions.push(questionData);
                        currentStep += 2;
                        updateProgress(currentStep, totalSteps, `Completed Q${i + 1} of ${questions.length}`);
                    } catch (error) {
                        console.error(`Error processing question ${i + 1}:`, error);
                        showToast(`Error on Q${i + 1}: ${error.message}`, 'error');
                        
                        // Create placeholder for failed question
                        processedQuestions.push({
                            index: i + 1,
                            originalQuestion: question,
                            error: error.message,
                            arabic: { question: '', tags: [], synonyms: [], responses: [], questionId: null, apiCalls: { createQuestion: { status: 'error', error: error.message }, addTags: [], addSynonyms: [], addResponses: [] }},
                            english: { question: '', tags: [], synonyms: [], responses: [], questionId: null, apiCalls: { createQuestion: { status: 'error', error: error.message }, addTags: [], addSynonyms: [], addResponses: [] }}
                        });
                        currentStep += 2;
                    }
                }

                showToast('Processing complete!', 'success');
                displayResults();
            } catch (error) {
                showToast('Processing failed: ' + error.message, 'error');
                console.error(error);
            } finally {
                isProcessing = false;
                document.getElementById('processBtn').disabled = false;
                document.getElementById('progressSection').classList.remove('active');
                document.getElementById('resultsSection').classList.add('active');
            }
        }

        async function processQuestion(question, index, instructions = '') {
            const provider = document.getElementById('aiProvider').value;
            const model = document.getElementById('aiModel').value;
            const apiKey = document.getElementById('apiKey').value;
            
            const questionData = {
                index: index,
                originalQuestion: question,
                arabic: {
                    question: '',
                    questionId: null,
                    tags: [],
                    synonyms: [],
                    responses: [],
                    apiCalls: {
                        createQuestion: { status: 'pending', error: null },
                        addTags: [],
                        addSynonyms: [],
                        addResponses: []
                    }
                },
                english: {
                    question: '',
                    questionId: null,
                    tags: [],
                    synonyms: [],
                    responses: [],
                    apiCalls: {
                        createQuestion: { status: 'pending', error: null },
                        addTags: [],
                        addSynonyms: [],
                        addResponses: []
                    }
                }
            };

            // Generate AI content
            const aiContent = await generateAIContent(question, provider, model, apiKey, instructions);
            
            // Assign generated content
            questionData.arabic.question = aiContent.arabic.question;
            questionData.arabic.tags = aiContent.arabic.tags || [];
            questionData.arabic.synonyms = aiContent.arabic.synonyms || [];
            questionData.arabic.responses = aiContent.arabic.responses || [];

            questionData.english.question = aiContent.english.question;
            questionData.english.tags = aiContent.english.tags || [];
            questionData.english.synonyms = aiContent.english.synonyms || [];
            questionData.english.responses = aiContent.english.responses || [];

            // Initialize API call statuses
            const tagsCount = Math.max(questionData.arabic.tags.length, questionData.english.tags.length, 5);
            const synonymsCount = Math.max(questionData.arabic.synonyms.length, questionData.english.synonyms.length, 10);
            const responsesCount = Math.max(questionData.arabic.responses.length, questionData.english.responses.length, 2);

            for (let i = 0; i < tagsCount; i++) {
                questionData.arabic.apiCalls.addTags.push({ status: 'pending', error: null });
                questionData.english.apiCalls.addTags.push({ status: 'pending', error: null });
            }
            for (let i = 0; i < synonymsCount; i++) {
                questionData.arabic.apiCalls.addSynonyms.push({ status: 'pending', error: null });
                questionData.english.apiCalls.addSynonyms.push({ status: 'pending', error: null });
            }
            for (let i = 0; i < responsesCount; i++) {
                questionData.arabic.apiCalls.addResponses.push({ status: 'pending', error: null });
                questionData.english.apiCalls.addResponses.push({ status: 'pending', error: null });
            }

            // Process both languages in PARALLEL
            await Promise.all([
                processLanguage(questionData, 'arabic', 1),
                processLanguage(questionData, 'english', 2)
            ]);

            return questionData;
        }

        async function generateAIContent(question, provider, model, apiKey, instructions = '') {
            const contextSection = instructions ? `\n\nContext/Category Information:\n${instructions}\n` : '';
            
            const prompt = `You are an expert FAQ content generator optimized for Rule-Based FAQ Search Systems.

Given this FAQ question: "${question}"${contextSection}

## HOW THE FAQ SEARCH SYSTEM WORKS

The search system looks for FAQs in this priority order:
1. **EXACT + PHRASE Search** (Highest Priority) - Searches in: Main Question + All Synonyms
2. **Stemmed Search** (Medium Priority) - Searches using word roots
3. **Tags Search** (Lowest Priority) - Searches in general keywords

## GENERATION GUIDELINES

### QUESTIONS - Best Practices:
‚úÖ Write as the customer would ACTUALLY ask (natural language)
‚úÖ Keep it SHORT and DIRECT (under 10 words)
‚úÖ Use colloquial/common phrasing
‚ùå Avoid overly long questions with unnecessary details

### SYNONYMS - Strategy for Maximum Match Rate (10 synonyms):
The synonyms are the MOST IMPORTANT element! They must cover ALL ways a customer might ask the same question.

Distribution Strategy (10 synonyms):
| #   | Type                    | Description                                      |
|-----|-------------------------|--------------------------------------------------|
| 1-2 | Direct question forms   | Alternative ways to ask the same question        |
| 3-4 | Keywords/phrases        | Key terms without question format                |
| 5-6 | Dialect variations      | Gulf Arabic, Egyptian, Levantine, etc.           |
| 7-8 | Alternative phrasings   | Different word choices, formal/informal          |
| 9-10| Common misspellings/abbr| Typos users commonly make, shortcuts             |

Arabic Dialect Examples:
- Gulf: "ŸÖÿ™Ÿâ ÿ™ÿ¥ÿ™ÿ∫ŸÑŸàŸÜÿü" 
- Levantine: "ÿßŸäŸÖÿ™Ÿâ ÿ®ÿ™ŸÅÿ™ÿ≠Ÿàÿü"
- Egyptian: "ÿ®ÿ™ŸÅÿ™ÿ≠Ÿàÿß ÿßŸÖÿ™Ÿâÿü"

### TAGS - Rules:
Tags are single ROOT WORDS for fallback search.
‚úÖ Single words only (NOT phrases)
‚úÖ Root form without articles ("ÿπŸÖŸÑ" not "ÿßŸÑÿπŸÖŸÑ")
‚úÖ Core concept words
‚ùå No compound phrases
‚ùå No articles (ÿßŸÑ, the, a, an)
‚ùå No conjugated verbs (use infinitive/root)

Example Tags for "What are your working hours?":
- Arabic: ["ÿ≥ÿßÿπÿßÿ™", "ÿπŸÖŸÑ", "ÿØŸàÿßŸÖ", "ŸÅÿ™ÿ≠", "ŸàŸÇÿ™"]
- English: ["hours", "work", "schedule", "open", "time"]

### RESPONSES:
Generate 2 varied responses for diversity:
- Response 1: Direct and concise
- Response 2: Slightly more detailed/friendly

## OUTPUT FORMAT

Respond with ONLY this JSON (no additional text):

{
  "arabic": {
    "question": "Short, direct question as customer would ask in Arabic",
    "tags": ["tag1", "tag2", "tag3", "tag4", "tag5"],
    "synonyms": [
      "Direct question form 1",
      "Direct question form 2", 
      "Keyword phrase 1",
      "Keyword phrase 2",
      "Gulf dialect variation",
      "Egyptian dialect variation",
      "Alternative phrasing 1",
      "Alternative phrasing 2",
      "Common misspelling/shortcut 1",
      "Common misspelling/shortcut 2"
    ],
    "responses": [
      "Concise professional response",
      "Slightly more detailed friendly response"
    ]
  },
  "english": {
    "question": "Short, direct question as customer would ask in English",
    "tags": ["tag1", "tag2", "tag3", "tag4", "tag5"],
    "synonyms": [
      "Direct question form 1",
      "Direct question form 2",
      "Keyword phrase 1", 
      "Keyword phrase 2",
      "Informal variation 1",
      "Informal variation 2",
      "Alternative phrasing 1",
      "Alternative phrasing 2",
      "Common misspelling/shortcut 1",
      "Common misspelling/shortcut 2"
    ],
    "responses": [
      "Concise professional response",
      "Slightly more detailed friendly response"
    ]
  }
}

CRITICAL REQUIREMENTS:
1. Question: Short (<10 words), natural customer language
2. Tags: Exactly 5 single ROOT words (no articles, no phrases)
3. Synonyms: Exactly 10, following the distribution strategy above
4. Responses: Exactly 2 comprehensive helpful answers
5. Cover Arabic dialects in synonyms (Gulf, Egyptian, Levantine)
6. Include common misspellings/typos users make
${instructions ? '7. IMPORTANT: Apply the provided context/category information for accuracy.' : ''}

üí° GOLDEN RULE: Synonyms are the KEY to matching! More variations = higher match rate.`;

            let response, data, content;

            try {
            if (provider === 'openai') {
                response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [
                                { role: 'system', content: 'You are a helpful FAQ assistant. Always respond with valid JSON only.' },
                            { role: 'user', content: prompt }
                        ],
                        temperature: 0.7,
                        max_tokens: 3000
                    })
                });

                if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error?.message || `OpenAI API error: ${response.status}`);
                }

                data = await response.json();
                content = data.choices[0].message.content.trim();

            } else if (provider === 'gemini') {
                response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-goog-api-key': apiKey
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                    text: `You are a helpful FAQ assistant. Always respond with valid JSON only.\n\n${prompt}`
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.7,
                            maxOutputTokens: 3000
                        }
                    })
                });

                if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error?.message || `Gemini API error: ${response.status}`);
                }

                data = await response.json();
                    
                    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                        throw new Error('Invalid Gemini response structure');
                    }
                    
                content = data.candidates[0].content.parts[0].text.trim();

            } else if (provider === 'openrouter') {
                response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`,
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'FAQ Batch Processor'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [
                                { role: 'system', content: 'You are a helpful FAQ assistant. Always respond with valid JSON only.' },
                            { role: 'user', content: prompt }
                        ],
                        temperature: 0.7,
                        max_tokens: 3000
                    })
                });

                if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error?.message || `OpenRouter API error: ${response.status}`);
                }

                data = await response.json();
                content = data.choices[0].message.content.trim();
            }

            // Extract JSON from response
            let jsonMatch = content.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                    console.error('No JSON found in response:', content);
                    throw new Error('No valid JSON found in AI response');
                }

                let parsedContent;
                try {
                    parsedContent = JSON.parse(jsonMatch[0]);
                } catch (parseError) {
                    console.error('JSON parse error:', parseError, 'Content:', jsonMatch[0]);
                    throw new Error('Failed to parse AI response as JSON');
                }
                
                // Validate response structure
            if (!parsedContent.arabic || !parsedContent.english) {
                    throw new Error('AI response missing arabic or english sections');
            }
            
            if (!parsedContent.arabic.question || !parsedContent.english.question) {
                    throw new Error('AI response missing question fields');
                }

                // Ensure arrays exist
                parsedContent.arabic.tags = parsedContent.arabic.tags || [];
                parsedContent.arabic.synonyms = parsedContent.arabic.synonyms || [];
                parsedContent.arabic.responses = parsedContent.arabic.responses || [];
                parsedContent.english.tags = parsedContent.english.tags || [];
                parsedContent.english.synonyms = parsedContent.english.synonyms || [];
                parsedContent.english.responses = parsedContent.english.responses || [];

            return parsedContent;

            } catch (error) {
                console.error('AI Generation Error:', error);
                throw error;
            }
        }

        async function processLanguage(questionData, lang, languageId) {
            const assistantCode = document.getElementById('assistantCode').value.trim();
            const versionCode = document.getElementById('versionCode').value.trim();
            const faqId = document.getElementById('faqId').value.trim();
            const jwt = document.getElementById('jwt').value.trim();

            const langData = questionData[lang];

            // Skip if no question was generated
            if (!langData.question) {
                langData.apiCalls.createQuestion.status = 'error';
                langData.apiCalls.createQuestion.error = 'No question generated';
                return;
            }

            // Step 1: Create Question (must be done first to get questionId)
            try {
                const createResult = await createQuestion(assistantCode, versionCode, faqId, languageId, langData.question, jwt);
                langData.questionId = createResult.createdId;
                langData.apiCalls.createQuestion.status = 'success';
            } catch (error) {
                langData.apiCalls.createQuestion.status = 'error';
                langData.apiCalls.createQuestion.error = error.message;
                return;
            }

            // Step 2: Add Tags, Synonyms, and Responses in PARALLEL
            const tagPromises = langData.tags.map((tag, i) => 
                addTag(assistantCode, versionCode, faqId, languageId, langData.questionId, tag, jwt)
                    .then(() => {
                        if (langData.apiCalls.addTags[i]) langData.apiCalls.addTags[i].status = 'success';
                    })
                    .catch(error => {
                        if (langData.apiCalls.addTags[i]) {
                            langData.apiCalls.addTags[i].status = 'error';
                            langData.apiCalls.addTags[i].error = error.message;
                        }
                    })
            );

            const synonymPromises = langData.synonyms.map((synonym, i) => 
                addSynonym(assistantCode, versionCode, faqId, languageId, langData.questionId, synonym, jwt)
                    .then(() => {
                        if (langData.apiCalls.addSynonyms[i]) langData.apiCalls.addSynonyms[i].status = 'success';
                    })
                    .catch(error => {
                        if (langData.apiCalls.addSynonyms[i]) {
                            langData.apiCalls.addSynonyms[i].status = 'error';
                            langData.apiCalls.addSynonyms[i].error = error.message;
                        }
                    })
            );

            const responsePromises = langData.responses.map((response, i) => 
                addResponse(assistantCode, versionCode, faqId, languageId, langData.questionId, response, jwt)
                    .then(() => {
                        if (langData.apiCalls.addResponses[i]) langData.apiCalls.addResponses[i].status = 'success';
                    })
                    .catch(error => {
                        if (langData.apiCalls.addResponses[i]) {
                            langData.apiCalls.addResponses[i].status = 'error';
                            langData.apiCalls.addResponses[i].error = error.message;
                        }
                    })
            );

            // Execute ALL API calls in parallel (tags + synonyms + responses)
            await Promise.all([...tagPromises, ...synonymPromises, ...responsePromises]);
        }

        // API Functions
        async function createQuestion(assistantCode, versionCode, faqId, languageId, question, jwt) {
            const url = `${baseURL}/api/knowledge_ai/${assistantCode}/${versionCode}/faq/${faqId}/${languageId}/question`;
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${jwt}`
                },
                body: JSON.stringify({ question: question })
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.message || `Failed to create question: ${response.status}`);
            }

            return await response.json();
        }

        async function addTag(assistantCode, versionCode, faqId, languageId, questionId, tag, jwt) {
            const url = `${baseURL}/api/knowledge_ai/${assistantCode}/${versionCode}/faq/${faqId}/${languageId}/question/${questionId}/tag`;
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${jwt}`
                },
                body: JSON.stringify({ tag: tag })
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.message || `Failed to add tag: ${response.status}`);
            }

            return await response.json();
        }

        async function addSynonym(assistantCode, versionCode, faqId, languageId, questionId, synonym, jwt) {
            const url = `${baseURL}/api/knowledge_ai/${assistantCode}/${versionCode}/faq/${faqId}/${languageId}/question/${questionId}/synonym`;
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${jwt}`
                },
                body: JSON.stringify({ questionSynonym: synonym })
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.message || `Failed to add synonym: ${response.status}`);
            }

            return await response.json();
        }

        async function addResponse(assistantCode, versionCode, faqId, languageId, questionId, message, jwt) {
            const url = `${baseURL}/api/knowledge_ai/${assistantCode}/${versionCode}/faq/${faqId}/${languageId}/question/${questionId}/short_messages`;
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${jwt}`
                },
                body: JSON.stringify({ messageText: message })
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.message || `Failed to add response: ${response.status}`);
            }

            return await response.json();
        }

        function displayResults() {
            const resultsDiv = document.getElementById('questionResults');
            let html = '';

            let totalSuccess = 0;
            let totalError = 0;
            let totalAPICalls = 0;

            processedQuestions.forEach((q, index) => {
                const arabicStatus = getLanguageStatus(q.arabic);
                const englishStatus = getLanguageStatus(q.english);
                
                totalSuccess += arabicStatus.success + englishStatus.success;
                totalError += arabicStatus.error + englishStatus.error;
                totalAPICalls += arabicStatus.total + englishStatus.total;

                const overallStatus = (arabicStatus.error === 0 && englishStatus.error === 0) ? 'success' : 
                                     (arabicStatus.success === 0 && englishStatus.success === 0) ? 'error' : 'partial';

                html += `
                    <div class="question-item">
                        <div class="question-header" onclick="toggleQuestion(${index})">
                            <div class="question-title">
                                <span class="question-number">${q.index}</span>
                                <span>${escapeHtml(q.originalQuestion.substring(0, 50))}${q.originalQuestion.length > 50 ? '...' : ''}</span>
                            </div>
                            <span class="status-badge ${overallStatus}">
                                ${overallStatus === 'success' ? '‚úì Complete' : overallStatus === 'error' ? '‚úï Failed' : '‚ö† Partial'}
                            </span>
                        </div>
                        <div class="question-details" id="question-details-${index}">
                            <div class="lang-tabs">
                                <button class="lang-tab active" onclick="switchLang(${index}, 'arabic')">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</button>
                                <button class="lang-tab" onclick="switchLang(${index}, 'english')">English</button>
                            </div>
                            ${renderLanguageContent(q, 'arabic', index, true)}
                            ${renderLanguageContent(q, 'english', index, false)}
                        </div>
                    </div>
                `;
            });

            if (html === '') {
                html = '<div class="empty-state"><div class="empty-state-icon">üì≠</div><p>No results to display</p></div>';
            }

            resultsDiv.innerHTML = html;

            // Update stats
            document.getElementById('totalQuestions').textContent = processedQuestions.length;
            document.getElementById('successCount').textContent = totalSuccess;
            document.getElementById('errorCount').textContent = totalError;
            document.getElementById('totalAPICalls').textContent = totalAPICalls;

            // Show/hide retry button
            document.getElementById('retryBtn').style.display = totalError > 0 ? '' : 'none';
        }

        function renderLanguageContent(q, lang, qIndex, isActive) {
            const langData = q[lang];
            const calls = langData.apiCalls;

            return `
                <div class="lang-content ${isActive ? 'active' : ''}" id="lang-${qIndex}-${lang}">
                    <div class="detail-section">
                        <h4>Question</h4>
                        <div class="detail-content">${escapeHtml(langData.question) || '<em>Not generated</em>'}</div>
                    </div>
                    
                    <div class="detail-section">
                        <h4>Tags (${langData.tags.length})</h4>
                        <div class="detail-content">
                            <div class="tag-list">
                                ${langData.tags.map(t => `<span class="tag">${escapeHtml(t)}</span>`).join('')}
                                ${langData.tags.length === 0 ? '<em>None</em>' : ''}
                        </div>
                        </div>
                    </div>
                    
                    <div class="detail-section">
                        <h4>Synonyms (${langData.synonyms.length})</h4>
                        <div class="detail-content">
                            <div class="synonym-list">
                                ${langData.synonyms.map((s, i) => `
                                    <div class="synonym-item">
                                        <span class="synonym-num">${i + 1}.</span>
                                        ${escapeHtml(s)}
                </div>
                                `).join('')}
                                ${langData.synonyms.length === 0 ? '<em>None</em>' : ''}
                            </div>
                        </div>
                    </div>
                    
                    <div class="detail-section">
                        <h4>Responses (${langData.responses.length})</h4>
                        <div class="detail-content">
                            ${langData.responses.map((r, i) => `<p><strong>${i + 1}.</strong> ${escapeHtml(r)}</p>`).join('')}
                            ${langData.responses.length === 0 ? '<em>None</em>' : ''}
                        </div>
                    </div>
                    
                    <div class="detail-section">
                        <h4>API Status</h4>
                        <div class="api-status-grid">
                            ${renderAPIItem('Question', calls.createQuestion, qIndex, lang, 'createQuestion')}
                            ${calls.addTags.slice(0, langData.tags.length).map((t, i) => renderAPIItem(`Tag ${i+1}`, t, qIndex, lang, 'addTags', i)).join('')}
                            ${calls.addSynonyms.slice(0, langData.synonyms.length).map((s, i) => renderAPIItem(`Syn ${i+1}`, s, qIndex, lang, 'addSynonyms', i)).join('')}
                            ${calls.addResponses.slice(0, langData.responses.length).map((r, i) => renderAPIItem(`Resp ${i+1}`, r, qIndex, lang, 'addResponses', i)).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAPIItem(name, status, qIndex, lang, type, subIndex = null) {
            const statusClass = status.status === 'success' ? 'success' : status.status === 'error' ? 'error' : 'pending';
            const retryBtn = status.status === 'error' ? 
                `<button class="btn-retry-small" onclick="event.stopPropagation(); retryAPICall(${qIndex}, '${lang}', '${type}', ${subIndex})">‚Üª</button>` : '';
            
            return `
                <div class="api-item">
                    <span class="api-dot ${statusClass}"></span>
                    <span>${name}</span>
                        ${retryBtn}
                </div>
            `;
        }

        function getLanguageStatus(langData) {
            let success = 0;
            let error = 0;
            let total = 0;

            const checkStatus = (call) => {
                if (!call) return;
                total++;
                if (call.status === 'success') success++;
                if (call.status === 'error') error++;
            };

            checkStatus(langData.apiCalls.createQuestion);
            langData.apiCalls.addTags.forEach(checkStatus);
            langData.apiCalls.addSynonyms.forEach(checkStatus);
            langData.apiCalls.addResponses.forEach(checkStatus);

            return { success, error, total };
        }

        function toggleQuestion(index) {
            const details = document.getElementById(`question-details-${index}`);
            details.classList.toggle('open');
        }

        function switchLang(qIndex, lang) {
            // Update tabs
            const tabs = document.querySelectorAll(`#question-details-${qIndex} .lang-tab`);
            tabs.forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            // Update content
            document.getElementById(`lang-${qIndex}-arabic`).classList.toggle('active', lang === 'arabic');
            document.getElementById(`lang-${qIndex}-english`).classList.toggle('active', lang === 'english');
        }

        async function retryAPICall(qIndex, lang, type, subIndex = null) {
            const question = processedQuestions[qIndex];
            const langData = question[lang];
            const languageId = lang === 'arabic' ? 1 : 2;

            const assistantCode = document.getElementById('assistantCode').value.trim();
            const versionCode = document.getElementById('versionCode').value.trim();
            const faqId = document.getElementById('faqId').value.trim();
            const jwt = document.getElementById('jwt').value.trim();

            showToast('Retrying...', 'info');

            try {
                if (type === 'createQuestion') {
                    const result = await createQuestion(assistantCode, versionCode, faqId, languageId, langData.question, jwt);
                    langData.questionId = result.createdId;
                    langData.apiCalls.createQuestion.status = 'success';
                    langData.apiCalls.createQuestion.error = null;
                } else if (type === 'addTags') {
                    await addTag(assistantCode, versionCode, faqId, languageId, langData.questionId, langData.tags[subIndex], jwt);
                    langData.apiCalls.addTags[subIndex].status = 'success';
                    langData.apiCalls.addTags[subIndex].error = null;
                } else if (type === 'addSynonyms') {
                    await addSynonym(assistantCode, versionCode, faqId, languageId, langData.questionId, langData.synonyms[subIndex], jwt);
                    langData.apiCalls.addSynonyms[subIndex].status = 'success';
                    langData.apiCalls.addSynonyms[subIndex].error = null;
                } else if (type === 'addResponses') {
                    await addResponse(assistantCode, versionCode, faqId, languageId, langData.questionId, langData.responses[subIndex], jwt);
                    langData.apiCalls.addResponses[subIndex].status = 'success';
                    langData.apiCalls.addResponses[subIndex].error = null;
                }

                showToast('Retry successful!', 'success');
                displayResults();
            } catch (error) {
                showToast('Retry failed: ' + error.message, 'error');
            }
        }

        async function retryAllFailed() {
            if (!confirm('Retry all failed API calls?')) return;

            showToast('Retrying all failed calls...', 'info');
            let retried = 0;

            for (let qIndex = 0; qIndex < processedQuestions.length; qIndex++) {
                const question = processedQuestions[qIndex];

                for (const lang of ['arabic', 'english']) {
                    const langData = question[lang];
                    const calls = langData.apiCalls;

                    if (calls.createQuestion.status === 'error') {
                        await retryAPICall(qIndex, lang, 'createQuestion');
                        retried++;
                    }
                    for (let i = 0; i < calls.addTags.length; i++) {
                        if (calls.addTags[i] && calls.addTags[i].status === 'error') {
                            await retryAPICall(qIndex, lang, 'addTags', i);
                            retried++;
                        }
                    }
                    for (let i = 0; i < calls.addSynonyms.length; i++) {
                        if (calls.addSynonyms[i] && calls.addSynonyms[i].status === 'error') {
                            await retryAPICall(qIndex, lang, 'addSynonyms', i);
                            retried++;
                        }
                    }
                    for (let i = 0; i < calls.addResponses.length; i++) {
                        if (calls.addResponses[i] && calls.addResponses[i].status === 'error') {
                            await retryAPICall(qIndex, lang, 'addResponses', i);
                            retried++;
                        }
                    }
                }
            }

            showToast(`Retry complete! ${retried} calls retried.`, 'success');
            displayResults();
        }

        function exportResults() {
            const exportData = {
                timestamp: new Date().toISOString(),
                configuration: {
                    assistantCode: document.getElementById('assistantCode').value,
                    versionCode: document.getElementById('versionCode').value,
                    faqId: document.getElementById('faqId').value
                },
                questions: processedQuestions
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `faq-batch-report-${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
            
            showToast('Report exported!', 'success');
        }

        function clearAll() {
            if (!confirm('Clear all data and results?')) return;
            
                document.getElementById('questions').value = '';
            document.getElementById('resultsSection').classList.remove('active');
                processedQuestions = [];
            showToast('All data cleared', 'info');
        }

        function escapeHtml(text) {
            if (!text) return '';
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return String(text).replace(/[&<>"']/g, m => map[m]);
        }
    </script>
</body>
</html>
